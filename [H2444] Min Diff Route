[Problem Description]

N cities are given. Each city has an ID ranging from 0 to N-1.

When a one-way road that connects cities is added, the ID and cost of the road are given.

When you travel from the departure city to the arrival city,
you want to minimize the difference between the maximum cost and the minimum cost required along the route.

[Fig. 1] is an example of five cities.



[Fig. 1]

If you travel from City 0 to City 4 using the following route,
the difference between the maximum cost and the minimum cost is 40. (70 - 30 = 40).
(0 --(cost:30)--> 1 --(cost:70)--> 3 --(cost:40)--> 4)

If you travel from City 0 to City 4 using the following route,
the difference between the maximum cost and the minimum cost is 30, which is the minimum difference. (70 - 40 = 30)
(0 --(cost:40)--> 2 --(cost:60)--> 1 --(cost:70)--> 3 --(cost:40)--> 4)

 

Implement each required function by referring to the following API description.

※ The function signature below is based on C/C++. As for other languages, refer to the provided Main and User Code.

 

The following is the description of API to be written in the User Code.

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])

This function is called at the beginning of each test case.
N cities are given. Each city has an ID ranging from 0 to N-1.
Information on K roads is given. It includes the ID, departure city, arrival city, and cost of each road.
All roads are one-way roads, which allow you to travel only from the departure city to the arrival city.
All roads have different pairs of departure city and arrival city from each other.
For all roads, the departure city and the arrival city are different from each other.
All roads have different IDs from each other.

Parameters
  N: Number of cities ( 5 ≤ N ≤ 300 )
  K: Number of roads ( 6 ≤ K ≤ 1,000 )

  For every i (0 ≤ i ＜ K),
  mId[i]: ID of Road i ( 1 ≤ mId[i] ≤ 1,000,000,000 )
  sCity[i]: Departure city of Road i ( 0 ≤ sCity[i] < N )
  eCity[i]: Arrival city of Road i ( 0 ≤ eCity[i] < N )
  mCost[i]: Cost of Road i ( 1 ≤ mCost[i] ≤ 500 )

void add(int mId, int sCity, int eCity, int mCost)

This functions adds Road mId whose departure city is sCity, arrival city is eCity, and cost is mCost.
Road mId is a one-way road, which allows you to travel only from the departure city to the arrival city.
A new city that was not given in init() is not given.
There is no existing road that connects sCity to eCity.
sCity and eCity are not the same.
mId is not the ID of an existing road.

Parameters
  mId: ID of the road ( 1 ≤ mId ≤ 1,000,000,000 )
  sCity: Departure city of the road ( 0 ≤ sCity < N )
  eCity: Arrival city of the road ( 0 ≤ eCity < N )
  mCost: Cost of the road ( 1 ≤ mCost ≤ 500 )

void remove(int mId)

This function removes Road mId.
mId is not the ID of a road that doesn’t exist.

Parameters
  mId: ID of the road ( 1 ≤ mId ≤ 1,000,000,000 )

int cost(int sCity, int eCity)

This function returns the minimum difference between the maximum cost and the minimum cost required along the route from sCity to eCity.
sCity and eCity are not the same.

Parameters
  sCity: Departure city ( 0 ≤ sCity < N )
  eCity: Arrival city ( 0 ≤ eCity < N )

Returns
  If it is possible to travel from sCity to eCity, the minimum difference between the maximum cost and the minimum cost is returned.
  If it is impossible, -1 is returned.

[Constraints]

1. init() is called at the beginning of each test case.

2. For each test case, add() is called up to 700 times.

3. For each test case, remove() is called up to 300 times.

4. For each test case, cost() is called up to 30 times.

--------------------------------------------

#include <bits/stdc++.h>
using namespace std;
 
const int N = 301;
map<int,int> mp;
int n;
const int inf = 1e9;
vector<array<int,3>> adj[N];
 
void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[]) {
    for(int i=0;i<N;i++) adj[i].clear();
    n = N;
    mp.clear(); 
 
    for(int i=0;i<K;i++) {
        adj[sCity[i]].push_back({mId[i], eCity[i], mCost[i]});
        mp[mId[i]]++;
    }
}
 
void add(int mId, int sCity, int eCity, int mCost) {
    adj[sCity].push_back({mId, eCity, mCost});
    mp[mId]++;
}
 
void remove(int mId) {
    mp.erase(mId);
    return;
}
 
struct cmp {
    bool operator()(array<int,3> a, array<int,3> b) const {
        return a[2] - a[1] > b[2] - b[1];
    }
};
 
int cost(int sCity, int eCity) {
    vector<vector<int>> vis(n+1, vector<int>(501, 0));
    priority_queue<array<int,3>, vector<array<int,3>>, cmp> pq;
 
    pq.push({sCity, inf, 0}); // node mini maxi
 
    while(pq.size()) {
        auto [node, m1, m2] = pq.top();
        pq.pop();
        int diff = m2 - m1;
 
        if(node == eCity) return diff;
 
        if(m1 <= 500 && m2 >= 0 && vis[node][m1]) continue;
        if(m1 <= 500) vis[node][m1] = 1;
         
        for(auto &[id, v, w] : adj[node]) {
            if(mp.find(id) == mp.end()) continue;
            pq.push({v, min(m1, w), max(m2, w)});
        }
    }
    return -1;
}

----------------------------------------------------------------------------------------------

#include <bits/stdc++.h>
using namespace std;
struct Node{
    int st, end, cost, id;
};
unordered_map<int, int>mp;
vector<Node> arr[302];
int End;
int vis[301];
void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[]){
    mp.clear();
    for(int i = 0;i < 302; i++)
        arr[i].clear();
    for(int i = 0;i < K;i++){
        mp[mId[i]] = sCity[i];
        arr[sCity[i]].push_back({ sCity[i],eCity[i],mCost[i],mId[i] });
    }
}
void add(int mId, int sCity, int eCity, int mCost){
    mp[mId] = sCity;
    arr[sCity].push_back({ sCity,eCity,mCost ,mId});
} 
void remove(int mId){
    int start_city = mp[mId];
    for(auto it = arr[start_city].begin();it != arr[start_city].end();){
        if(it->id == mId){
            arr[start_city].erase(it);
            break;
        }
        it++;
    }
}
bool possible(int start, int min, int max){
    if(start == End)
        return true;
    if(vis[start] == 1)
        return false;
    vis[start] = 1;
    for(auto it : arr[start]){
        if(it.cost<min || it.cost>max)
            continue;
        if(possible(it.end, min, max))
            return true;
    }
    return false;
}
int cost(int sCity, int eCity){
    int low = 0, high = 500;
    End = eCity;
    int ans = 10000;
    while(low <= high){
        int mid = (low + high) >> 1;
        bool f = false;
        for(int i = 1; i <= 500 - mid; i++){
            memset(vis, 0, sizeof(vis));
            if(possible(sCity, i, i + mid)){
                f = true;
                break;
            }
        }
        if(f){
            ans = mid;
            high = mid - 1;
        }
        else low = mid + 1;
    }
    if(ans == 10000)return -1;
    return ans;
}
