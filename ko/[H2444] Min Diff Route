#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>
#include <climits>

using namespace std;

// Global variables
int N;
vector<vector<pair<int, int>>> graph;
unordered_map<int, tuple<int, int, int>> roads;

void init(int N_param, int K, int mId[], int sCity[], int eCity[], int mCost[]) {
    N = N_param;
    graph.clear();
    graph.resize(N);
    roads.clear();
    
    for (int i = 0; i < K; i++) {
        roads[mId[i]] = make_tuple(sCity[i], eCity[i], mCost[i]);
        graph[sCity[i]].push_back({eCity[i], mCost[i]});
    }
}

void add(int mId, int sCity, int eCity, int mCost) {
    roads[mId] = make_tuple(sCity, eCity, mCost);
    graph[sCity].push_back({eCity, mCost});
}

void remove(int mId) {
    if (roads.find(mId) == roads.end()) return;
    
    roads.erase(mId);
    
    // Rebuild graph efficiently
    for (int i = 0; i < N; i++) {
        graph[i].clear();
    }
    
    for (const auto& road : roads) {
        int s = get<0>(road.second);
        int e = get<1>(road.second);
        int c = get<2>(road.second);
        graph[s].push_back({e, c});
    }
}

int cost(int sCity, int eCity) {
    if (sCity == eCity) return 0;
    if (sCity < 0 || sCity >= N || eCity < 0 || eCity >= N) return -1;
    
    vector<int> dist(N, INT_MAX);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    
    dist[sCity] = 0;
    pq.push({0, sCity});
    
    while (!pq.empty()) {
        int currDist = pq.top().first;
        int curr = pq.top().second;
        pq.pop();
        
        if (curr == eCity) return currDist;
        
        if (currDist > dist[curr]) continue;
        
        for (const auto& edge : graph[curr]) {
            int to = edge.first;
            int edgeCost = edge.second;
            
            if (to >= 0 && to < N) {  // Bounds check
                int newDist = currDist + edgeCost;
                if (newDist < dist[to]) {
                    dist[to] = newDist;
                    pq.push({newDist, to});
                }
            }
        }
    }
    
    return -1;
}
