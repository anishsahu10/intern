[Problem Description]

A department store plans to play music to improve employee satisfaction.

To maximize its impact, the store wants to select a time slot when the most employees can listen to the music.

To this end, they are checking how many employees can listen to the music during an arbitrary time slot.

 

[Fig. 1] is the start and end times of the employees’ shifts.



If the music begins at 1275 and finishes at 1530, five employees listen to the entire piece of music.

 

Given the start and end times of the employees’ shifts, write a program that counts how many employees listen to the music at an arbitrary time.

 

Implement each required function by referring to the following API description.

※ The function signature below is based on C/C++. As for other languages, refer to the provided Main and User Code.

 

The following is the description of API to be written in the User Code.

 

void init(int musicTime)

This function is called at the beginning of each test case.

 

The total time for the music is musicTime.

 

No start or end times for shifts have been added.

 

 

Parameters

  musicTime: Total time for the music ( 100 ≤ musicTime ≤ 500 )

void add(int mID, int mStart, int mEnd)

This function adds mStart and mEnd of Employee mID.

 

mEnd - mStart of Employee mID is between 1,000 and 1,000,000.

 

If the ID already exists, change the existing mStart and mEnd instead of adding a new one.

The removed employee could be added again.

 

 

Parameters

  mID: Employee ID ( 1 ≤ mID ≤ 1,000,000,000 )

  mStart: Shift start time ( 0 < mStart < 1,700,000 )

  mEnd: Shift end time ( mStart < mEnd < 2,000,000 )

void remove(int mID)

This function removes mStart and mEnd of Employee mID.

Employee ID that has already been removed could be given.

 

Parameters

mID: Employee ID ( 1 ≤ mID ≤ 1,000,000,000 )

int getCnt(int mBSTime)

This function returns the number of employees who listen to the entire piece of music when it begins at mBSTime.

(The total time for the music is musicTime.)

 

Ensure that employees starting or ending their shifts while the music is playing are excluded.

(However, employees who start their shifts when the music begins and those who end their shifts when the music finishes are included.)


For example, if musicTime is 250 and mBSTime is 1,000, employees who start their shifts at 1,000 or those who end at 1,250 are included.

However, employees who start their shifts at 1,001 or those who end at 1,249 are excluded.

 

 

Parameters

  mBSTime: Start time of the music ( 0 < mBSTime < 1,990,000 )

 

Returns

 Number of employees who listen to the entire piece of music when it begins at mBSTime

[Constraints]

1. init() is called at the beginning of each test case.

2. For each test case, it is guaranteed that start and end times of employees’ shifts are assigned randomly.

3. For each test case, add() is called up to 5,000 times.

4. For each test case, remove() is called up to 500 times.

5. For each test case, getCnt() is called up to 30,000 times.

------------------------------------------------------------------------------------------------------------------------------------------

#include<iostream>
#include<unordered_map>
#include<cstring>
 
using namespace std;
 
#define Bsize 2000001
 
int BITree[Bsize];
 
struct Node {
    int id;
    int start;
    int end;
}pool[5001];
 
 
unordered_map<int, int> mp;
 
 
void update(int index,int val) {
    index++;
 
    while (index < Bsize) {
        BITree[index] += val;
        index += index & (-index);
    }
}
 
int query(int index) {
    index++;
    int sum = 0;
 
    while (index > 0) {
        sum += BITree[index];
        index -= index & (-index);
    }
 
    return sum;
}
 
 
 
 
 
 
int idx;
int musicDuration;
void init(int musicTime)
{
    mp.clear();
    idx = 0;
    musicDuration = musicTime;
 
    memset(BITree, 0, sizeof(BITree));
 
}
 
void add(int mID, int mStart, int mEnd)
{
     
    if (mp.find(mID) != mp.end()) {
        int id = mp[mID];
        mp.erase(mID);
        update(pool[id].start, -1);
        update(pool[id].end + 1 - musicDuration, 1);
    }
    mp[mID] = idx;
    pool[idx].id = mID;
    pool[idx].start = mStart;
    pool[idx].end = mEnd;
 
    idx++;
 
    // update in fenvick
 
    update(mStart, 1);
    update(mEnd + 1 - musicDuration, -1);
 
}
 
void remove(int mID)
{
    if (mp.find(mID) == mp.end()) {
        return;
    }
 
    int id = mp[mID];
 
    mp.erase(mID);
 
    update(pool[id].start, -1);
    update(pool[id].end + 1 - musicDuration, 1);
}
 
int getCnt(int mBSTime)
{
    int ans = query(mBSTime);
    return ans;
}
